In order to develop these methods we have used two main frameworks. The first is both a programming paradigm and a declarative programming language: the Answer Set Programming (ASP).
The second framework is the Process Hitting (PH) a previously introduced formalism for the representation of biological regulatory networks.

\subsection{Answer Set Programming }

\emph{Answer Set Programming} (ASP) is a declarative programming paradigm with semantics known as the \emph{semantics of answer sets}.
This paradigm allows the programmer to specify what the problem to be solved is, and not how to solve it.
ASP programs are written in AnsProlog* (short for "Answer Set Programming in Logic" with superscript:~*).
These programs are composed of a set of \emph{facts} and a set of \emph{rules}, as defined below, from which other facts can be derived.
A consistent set of facts that can be derived from a program using the rules is called \emph{answer set} for the program.
The sets of possible responses to an AnsProlog* program are calculated with a program called a solver.

\subsubsection{Logic program}
An ASP program is composed of rules, each one being an ordered pair~\cite{baral2003knowledge}:
\begin{equation} \label{eq1ASP}
head \leftarrow body.
\end{equation}
with $head$ and $body$ two sets of literals. 

This simple language has many advantages that make it very effective in terms of knowledge representation, reasoning and declarative problem solving. 
\annotMF{Source ? Sinon : “one of the most” $\Rightarrow$ “very”} \repEB{OK}

\subsubsection{The syntax and semantic of ASP}
\label{sectionSyntaxeASP}
\begin{enumerate}
\item \textbf{The alphabet}

\noindent{ According to \cite{baral2003knowledge}, the alphabet of the axioms (or simply called the \emph{alphabet}) of ASP is composed of seven classes of symbols:
\begin{itemize}
\item Variables,
\item Constants,
\item Symbols of functions,
\item Symbols of predicates,
\item Connectors,	
\item Symbols of punctuation,
\item The special symbol $\bot$
\end{itemize}
}
All these classes vary from one alphabet to another, but the sets of $ 5^{th} $ and $ 6^{th} $ classes (Connectors and symbols of punctuation) are defined as follows:
\begin{itemize}
  \item Connectors with \{$\neg$, or, $\leftarrow$, not, ‘,’\}
  \item Symbols of punctuation with \{‘(’, ‘)’, ‘.’\}
\end{itemize}

\annotMF{Il faut absolument décider d'une charte d'écriture pour les programmes ASP dans ce texte, d'autant plus qu'actuellement cette charte change entre la section courant (où le code est écrit en mode \$maths\$) et la suite où il est en mode \texttt{listing}.}
\repEB{T’as raison au début j’ai écrit tout le code en mode $math$ et puis j’ai changé juste la partie du code et j’ai oublié de faire la mise à jour de cette partie de définition d’ASP}
The other classes remain constant as they meet some informal agreement. In general, variables start with a capital letter and contain letters and numbers, but often only one capital letter is used (\eg X, Y, ...).
The constants, symbols and predicates follow the same rule, but they begin with a lowercase letter (\eg f, g, a, b, ...).
String surrounded by quotation marks are also considered as constants (\eg "f", "g", "a b c", ...).

\annotMF{Je ne suis pas sûr que l'explication sur les prédicats soit pertinente. Si on la garde, il faudrait la reformuler.}
What seems a little fuzzy is the concept of predicate. Indeed the word predicate can be an innovation of the new grammar. Let's consider the following sentence: 
\begin{tabbing}
 \textit{Socrates was an athenian.} 
\end{tabbing}
\textit{Socrate} is the subject and \textit{was an athenian} is the predicat. This sentence can be noted in ASP by :
\begin{tabbing}
 \texttt{athenian(Socrate) $\leftarrow ~ \top$. }\hspace{2cm} with \texttt{$\top$}  is the symbol of True.
\end{tabbing} 

\item \textbf{The rules}
As previously mentioned, a rule has the following form:
\texttt{
\begin{equation*} \label{eq3ASP}
 A ~ \leftarrow ~ B^+, ~ \ASPnot B^-.
\end{equation*}
}

where the part on the left of the arrow is called $ head$
and the right part is called $body$.
This rule is then equivalent to:
\texttt{
\begin{equation*} \label{eq2ASP}
l_{0} \leftarrow l_{1},...,l_{m}, \ASPnot l_{m+1},..., \ASPnot l_{n}.
\end{equation*}
}
And this rule states:
\[
\left.
    \begin{array}{ll}
        \text{If} ~ \texttt{$l_{1},...,l_{m}$}  ~ \text{are \textbf{true}}\\
        \text{and} ~ \texttt{$l_{m+1},...,l_{n}$} ~ \text{are \textbf{false}}
    \end{array}
\right \} \text{Then} ~ \texttt{$ l_{0} $} ~ \text{is } \textbf{true} 
\]
with \texttt{$l_{i}$} literals for all $i \in \llbracket 1 ; n \rrbracket$, and $0 \leq m \leq n$.
Therefore, $head$ is also called the \emph{conclusion} of the rule,
and \texttt{body} is its \emph{premise}.

There are some special cases of rules \cite{Vladimir,baral2003knowledge}:
\begin{itemize}
\item A rule is said \textbf{constant} or \emph{ground} if all of its literals are constants;
\item A \textbf{fact} or a \textbf{reality} is a rule with an empty body.
  It can be written without the central arrow ($\leftarrow$) or with a body equal to $\top$:
  \texttt{
\begin{equation} 
l_{0} \leftarrow \top. \qquad \text{or} \qquad l_{0}.
 \label{eq5ASP}
\end{equation}
}

\item A \textbf{constraint} is a rule where the head equals false ($\bot$).
  In this case, the head is often not represented and the constraint will be written generally as:
\begin{equation} 
  \leftarrow l_{1},...,l_{m}, \ASPnot l_{m+1},..., \ASPnot l_{n}.
  \label{eq6ASP}
\end{equation}

We say that a set of literals $X$ violates the constraint \eqref{eq6ASP} if $\{l_{1},...,l_{m}\} \subseteq X$ and $\{l_{m+1},...,l_{n}\} \nsubseteq X$.
If a program $\pi$ contains such a constraint $r$, then $X$ is an answer set of $\pi$ if and only if $X$ is an \textit{answer set} of $\pi \setminus \{r\}$ and $X$ does not violate $r$.

\item A \emph{cardinality constraint} is a rule of the following form:
\begin{equation} 
 ~ l ~\{q_{1},~ ... ,~ q_{m}\}~ u \leftarrow body.
 \label{eq7ASP}
\end{equation}
with $m \geq 1$, $l$ an integer and $u$ an integer or the infinity ($\infty$). \repEB{ This form of rule \ref{eq7ASP} is used when the body can lead to several $q_i$ atoms and also when the programmer need to have more than an atom of type $q_i$. But that the number of this atoms $q_i$ should be between $l$ and $m$. That means that it is possible to find the same atom repeated many times at one answer set.}  \\
In addition the literals $q_i$ can also appear in the body of the rule,
and $l$ and $u$ are the lower and upper bounds of the number of these literals
that can appear in the answer sets.
%cardinality of the subsets of $ \{q_{1}, ... , q_{m}\}$ that satisfy the answer sets.
Therefore, a cardinality constraint is satisfied in an answer set $X$, if the number of atoms of $\{q_{1}, ... , q_{m}\}$ belonging to $X$ is between $l$ and $u$,
or, in other words, if:
\begin{equation}
  l \leq | \{q_{1},... , q_{m}\} \cap X | \leq u
\end{equation}
where $\cap$ is the symbol of the intersection of sets
and $|A|$ is the cardinality of the set $A$.
\modMF{%
In the following, if they are not explicitly given,
we consider that $l$ defaults to $0$ and $u$ defaults to $\infty$.
\annotMF{Les cardinalités ne sont pas seulement utilisées de cette manière ! Dans notre code, on les trouve dans la tête et dans le corps des règles.}
\todo{À compléter : cardinalités dans le corps des règles}
}%
\end{itemize}

\end{enumerate}



\subsubsection{Modeling of a problem with ASP}

We can consider that the construction of models is one of the fundamental components of the scientific process. It concerns all systems we seek to control. A model has two main features \cite{Glimpse}:
\begin{itemize}
\item it is a simplification of a given system,
\item it allows an action on the system \repEB{like resolving problems, searching for a path, identifying states ... }
\annotMF{Quel genre d'action ?} 
\end{itemize}
This concept model can address another angle issues related to representation process.

\begin{enumerate}
\item\textbf{Modeling steps}
The modeling process can be regarded as a special form of representation whose operations are detailed in \cite{baral2003knowledge}.
Logical ASP programs follow the strategy of “generate and test”.
This strategy includes four steps:
\begin{itemize}
\item Enumerate with facts;
\item Explain with rules;
\item Generate all the possibilities with cardinalities; and finally,
\item Filter with constraints.
\end{itemize}

\item \textbf{Solving an ASP program}
\modMF{%
The solving of ASP programs relies on a \emph{grounder} and a \emph{solver}
that usually work together:
}%
first the grounder is used to remove variables in order to achieve an equivalent but constant program,
then the solver computes all answer sets for a stabilized program generated by the grounder~\cite{Vladimir,AnsPrologAPE}.
Amongst all available grounders for ASP, we can name
\texttt{Gringo}, \texttt{DLV} and \texttt{LParse},
and the solvers include
\texttt{SModels}, \texttt{DLV}, \texttt{CModels}, \texttt{Clasp}...

\reformuler{
The combined use of the grounder and the solver specifies major programs in a compact, using rules with schematic variables and other abbreviations. Both systems employ grounding algorithms that work quickly and simplify the program.
}
\repEB{c'est à ajouter dans le paragraphe ou à reformuler?}
For the work presented in this paper, we worked with \texttt{Clingo} which is a combination of the grounder \texttt{Gringo} and the solver \texttt{Clasp}.

\end{enumerate}

