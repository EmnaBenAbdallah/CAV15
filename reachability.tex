%Section: Dynamic network evolution

In this section, firstly present how to determine the possible evolution of a PH model after a finite number of steps with an ASP program.
Then we tackle the reachability question: are there scenarios in a given initial state
that allow to reach a given goal (under the form of a set of processes)?

\subsection{Future states identification}
\reformuler{From an initial known state, a PH network can evolve into several new states after a few steps.}
\modMF{%
Firstly, we focus on the evolutions of the model in a limited number of steps.
}%
The predicate \texttt{time(0..n)} sets the number of steps we want to play.
\modMF{%
The value of \texttt{n} can be arbitrarily chosen.
For example, \texttt{time(0..10)} will be used to compute the 11 first steps,
including the initial state.
In order to specify such an initial state, we add several facts of the following form
to list the processes included in this state:
}%
\begin{lstlisting}
init(activeProcess("a",0)).
\end{lstlisting}
where \texttt{"a"} is the name of the sort and\texttt{"0"} the index of the active process.
The dynamics of a network is described by its actions,
identifying the future states requires to first identify the playable actions for each state.
We recall that an action is playable in a state when both its hitter and target are active in this state (see Definition \ref{def:playableAction}).
Therefore, we define an ASP predicate \texttt{playableAction(A,I,B,J,K,T)} that is true
when the processes \texttt{(A,I)} and \texttt{(B,J)} are active at step \texttt{T}.
\annotMF{Peut-être écrire : $\texttt{A}_\texttt{I}$ et $\texttt{B}_\texttt{J}$}
It is also needed to enforce the strictly asynchronous dynamic
which state that exactly one process can change between two steps.
We thus represent the change of the active process of a sort
by the predicate \texttt{"activeFromTo(B,J,K,T)"}
which means that in sort \texttt{B}, the active process changes from index \texttt{J} to \texttt{K} between steps \texttt{T} and \texttt{T+1}.
\annotMF{Peut-être écrire : $\texttt{B}_\texttt{J}$ et $\texttt{B}_\texttt{K}$}
\modMF{%
The cardinality rule of line \ref{e2} then
created as many answer sets as there are possible evolutions from the current step,
thus recreating all possible branchings in the possible evolutions of the model.
This allows to filter all scenarios where two actions have been played between
two steps, by using the constraint of \ref{e3}.
Thus, the remaining scenarios of the answer set all strictly follow
the asynchronous dynamics of the PH.
}%
\begin{lstlisting}
{activeFromTo(B,J,K,T)} :-  playableAction(A,I,B,J,K,T),
          instate(activeProcess(A,I),T), instate(activeProcess(B,J),T),
          J!=K, time(T). %\label{e2}
:- 2{ activeFromTo(B,J,K,T)}, time(T). %\label{e3}
\end{lstlisting}
\annotMF{N'est-il pas possible de réunir ces deux règles avec des bornes 1--1 de la façon suivante : 1 \{activeFromTo(B,J,K,T)\} 1 $\leftarrow$ ... ?}

In order to determinate the next active processes at \texttt{T+1} we use the following rules :
\begin{lstlisting}
instate(activeProcess(B,K),T+1) :-  activeFromTo(B,J,K,T), time(T). %\label{e4}
instate(activeProcess(A,I),T+1) :-  instate(activeProcess(A,I),T),
          activeFromTo(B,J,K,T), A!=B, time(T). %\label{e5}
\end{lstlisting}

At the next step \texttt{T+1} we find the new active process resulted from the predicate \texttt{activeFromTo} (line \ref{e4}) as well as all the unchanged processes that correspond to the other sorts (line \ref{e5}).\\
As a result it will be displayed all possible evolutions of the netwoks.
\subsection{Reachability verification}
In this section, we focus on the reachability of a process which corresponds to the question \ref{def:reachability} :\\
“Is it possible, starting from a given initial state, to play a number of actions so that a given processes are active in the resulting state?”

\noindent Now we try to adapt the code of network evolution to resolve the reachability problem. First we define a predicate for the objective processes we call it \texttt{"goal"}, we add a rule with this predicate to the script defining the PH :
\begin{lstlisting}
goal(activeProcess("a",1)). %\label{c1}
\end{lstlisting}
The rule line \ref{c1} verifies if after the network evolution, its state satisfies the goals at step \texttt{T}. Else the answer will be eliminated.
\begin{lstlisting}
satisfiable(F,T) :-  goal(F), instate(F,T). %\label{c2}
\end{lstlisting}
The limitation of this method is that the user has to choose the number of steps of the evolution. It is an disadvantage because a search in N steps will find no solution if the shortest path to solve the rechability requires N+1 steps. The solution is to use the incremental computation mode ( \textsc{iclingo} \cite{gebser2008user}).
So we have almost the same program expect for incremental step numbers. In each step t, the program computes the playable actions \texttt{playableAction(A,I,B,J,K,t)},the possible change \texttt{activeFromTo(B,J,K,t-1)} and the new active processes for the next step \texttt{instate(activeProcess(A,I),t+1)}. Regarding the part of local steps we use a special constraint (rule \textbf{c4}) that means that the program should continue to the next step if it's not satisfiable so that we eliminate responses that do not meet the goals.
\begin{lstlisting}
notSatisfiable(t) :-  goal(F), not instate(F,t). %\label{c3}
:- notSatisfiable(t). %\label{c4}
\end{lstlisting}
