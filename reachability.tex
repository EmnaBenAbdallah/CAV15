%Section: Dynamic network evolution

In this section, firstly present how to determine the possible evolution of a PH model after a finite number of steps with an ASP program.
Then we tackle the reachability question: are there scenarios in a given initial state
that allow to reach a given goal (under the form of a set of processes)?

\subsection{Future states identification}
Thanks to its actions, a PH network is considered like a dynamic model or a dynamic biological network. In fact starting from an initial state the network can envolve into several new states. Our objectif is to try to predict the next new states as well as to  see if other states are reachable and if it's the case to determine the path to reach them.
Firstly, we focus on the evolutions of the model in a limited number of steps.
So we define the predicate \texttt{time(0..n)} which sets the number of steps we want to play.
The value of \texttt{n} can be arbitrarily chosen.
For example, \texttt{time(0..10)} will be used to compute the 11 first steps,
including the initial state.
In order to specify such an initial state, we add several facts of the following form
to list the processes included in this state:
\begin{lstlisting}
init(activeProcess("a",0)).
\end{lstlisting}
where \texttt{"a"} is the name of the sort and \texttt{"0"} the index of the active process.
The dynamics of a network is described by its actions,
identifying the future states requires to first identify the playable actions for each state.
We recall that an action is playable in a state when both its hitter and target are active in this state (see Definition \ref{def:playableAction}).
Therefore, we define an ASP predicate \texttt{playableAction(A,I,B,J,K,T)} that is true
when the processes $\texttt{A}_\texttt{I}$ and $\texttt{B}_\texttt{J}$ are active at step \texttt{T}.
It is also needed to enforce the strictly asynchronous dynamic
which state that exactly one process can change between two steps.
We thus represent the change of the active process of a sort
by the predicate \texttt{"activeFromTo(B,J,K,T)"}
which means that in sort \texttt{B}, the active process changes from index $\texttt{B}_\texttt{J}$ to $\texttt{B}_\texttt{K}$ between steps \texttt{T} and \texttt{T+1}.
The cardinality rule of line \ref{e2} then
created as many answer sets as there are possible evolutions from the current step,
thus recreating all possible branchings in the possible evolutions of the model.
This allows to filter all scenarios where two actions have been played between
two steps, by using the constraint of line \ref{e3}.
Thus, the remaining scenarios of the answer set all strictly follow
the asynchronous dynamics of the PH.
\begin{lstlisting}
{activeFromTo(B,J,K,T)} :-  playableAction(A,I,B,J,K,T),
          instate(activeProcess(A,I),T), instate(activeProcess(B,J),T),
          J!=K, time(T). %\label{e2}
:- 2{ activeFromTo(B,J,K,T)}, time(T). %\label{e3}
\end{lstlisting}

Finally, the active processes at step \texttt{T+1},
that represent the next state depending on the chosen bounce,
can be computed by the following rules:
\begin{lstlisting}
instate(activeProcess(B,K),T+1) :-  activeFromTo(B,J,K,T), time(T). %\label{e4}
instate(activeProcess(A,I),T+1) :-  instate(activeProcess(A,I),T), %\label{e5}
          activeFromTo(B,J,K,T), A!=B, time(T). %\label{e5-a}
\end{lstlisting}
In other words, the state of step \texttt{T+1} contains one new active process
resulting from the predicate \texttt{activeFromTo} (line \ref{e4})
as well as all the unchanged processes that correspond to the other sorts (line \ref{e5} and \ref{e5-a}).

The overall result of the pieces of program presented in this subsection
is an answer set containing one answer for each
possible evolution in \texttt{n} time steps,
and starting from a given initial state.

\subsection{Reachability verification}
In this section, we focus on the reachability of set of processes which corresponds to the reachability question (see definition \ref{def:reachability}):
“Is it possible, starting from a given initial state, to play a number of actions so that a set of given processes are active in the resulting state?”
We now want to adapt the code of the dynamics computation of previous section in order to resolve this reachability problem.
For this, we first use a predicate to list the processes we want to reach, called \texttt{goal}, and we add as many rules of the following form as there are objective processes:
\begin{lstlisting}
goal(activeProcess("a",1)). %\label{c1}
\end{lstlisting}
Then, the literal \texttt{satisfiable(F, T)} 
checks if a given process \texttt{F} of the goal
is contained in the state of step \texttt{T},
as defined in the rule of line \ref{c2}.
Else the answer will be eliminated by the constraint \ref{c2-a} which verifies if all processes of the goal are satisfied.
\begin{lstlisting}
satisfiable(F, T) :-  goal(F), instate(F, T). %\label{c2}
\end{lstlisting}

However, the limitation of the method above is that the user has to decide upstream
the number of computed steps that should be sufficient.
It is a main disadvantage because a search in $N$ steps will find no solution
if the shortest path to the goal requires $K$ steps with $K > N$. It also may lengthen the resolution if the shortest path requires $n$ steps with $n << N$.
One solution is to use an incremental computation mode,
which is especially tackled by the incremental solver \textsc{iclingo}~\cite{gebser2008user}. In fact \textsc{iclingo} further includes the following guidelines:

\begin{tabbing}
\texttt{\#base.}  \\
... (static code for definitions) ... \\
\texttt{\#cumulative constant.}  \\
... (code depending on constant: body iteration) ... \\
\texttt{\#volatile constant.} \\
... (code for testing the satisfiyability property : stop computing iteration) ...
\end{tabbing}

Via \texttt{"\#base."} the subsequent part of a logic program is declared as static, that is, it is processed only once at the beginning of an incremental computation. In contrast, \texttt{"\#cumulative constant."} and \texttt{"\#volatile constant."}  are used to declare a (symbolic) constant as a placeholder for incremental step numbers.
In the following our constant is denoted by \texttt{"t"} indicate the number of a step in the evolution of the network.
Thus, the obtained program is almost identical,
except that step numbers \texttt{N}
are replaced by constant placeholders \texttt{"t"}
that will be incremented throughout the execution (body iteration).
In each step \texttt{t}, the program computes the playable actions \texttt{playableAction(A,I,B,J,K,t)}, the possible bounces \texttt{activeFromTo(B,J,K,t-1)}
and the new states \texttt{instate(activeProcess(A,I),t+1)}
in the same way than previously.
Regarding the part of local steps, that is, all rules, facts, and integrity constraints computed in one step are dismissed before the next incremental step,
we use a special constraint (line \ref{c4})
which states that the program should continue to the next step
while it is not satisfiable,
so that all answers that do not meet the goals are eliminated:
\begin{lstlisting}
notSatisfiable(t) :-  goal(F), not instate(F,t). %\label{c3}
:- notSatisfiable(t). %\label{c4}
\end{lstlisting}
